
## 状态管理，使用rees替代redux
1. 为什么需要状态管理库：
  所谓状态管理，我们先抛开redux的理论依据，即取代mvc、mvvm的前端架构，Flux。简单的说，项目中会大量遇到的实际问题：组件之间的通信。react标准的做法，是逐层的往下，通过设置props，来自上而下的传递数据。
  多数情形下，哪怕是中小型项目，组件层次很深，这种传递属性的方式，会显得格外的难受。比如最简单的，某个组件，需要这个属性，而其上层组件，不需要这个属性，但你必须一点点的往下传递。
1. 先行生态中，redux几乎是霸主级别的、唯一的选择
  react编程，几乎有90%以上的，会用redux管理状态。近年新出的mobx，是替代redux的选择之一。
  但两者都存在同样的毛病，即非常重，学习曲线陡峭。
1. redux的问题：概念多，学习曲线陡峭，编写代码的方式繁琐，没有异步处理
1. rees：实际项目中的产物，针对redux的缺点
  我们根据以前项目中，使用的小型的状态管理库，在最近一周，做了一些整理，形成一个比较舒服的、轻量级的rees。我们主要的工作，是将先前的状态库，基本的核心函数，都编写api覆盖，对api操作做了进一步的简化，支持多个Store，每个store支持多个业务对象。同时，使用proxy,为业务对象挂载的action，实现自动的setState，并处理各个业务对象的id
1. rees的学习非常简单，当然，这是和redux比较
  学习时间，给大家留出3-5天。要知道，redux没有两周，大概没法子入门的，没有两个月，估计在各种场景编程并不容易。
  redux可以做的事情，rees都可以。redux需要300行代码实现的功能，rees大概只需要100行。
  redux不具备的异步处理，rees有很好的实现方案。别小看这一点，redux通过多种第三方库，比如redux-thunk,redux-saga，来实现异步状态管理，这些库的选择就成问题，而且并没有深入到ui层面。
  异步处理是随时可用的，比如一个组件，先要从服务端获取数据，之后可能点击按钮刷新数据。。。这些都是异步操作，遍及整个应用。
1. 我们也将提供rees-router，取代常用的react-router

## rees的基本概念：
rees的api很简单
1. createStore
  创建一个store,该store有一个provider hoc函数，用于为组件提供状态
  store可以挂载业务对象
  当我们的顶层组件，用store.provider包裹之后，则整个组件树，都可以使用store中的状态、并更新其中的状态引发界面的render
  比如我们为整个应用定义store，包括常用的user(处理登录、注销、注册等)，假设我们的user是一个业务类
  另外比如有个theme业务类，用来管理主题
  let app=createStore({counter:0},{user,theme})
  这是createStore的基本用法，第一个参数，counter:0将直接出现在状态中
  第二个参数，是一些业务类，要求它有一个函数initState,用来初始化状态
  {user，theme}，表示将user,theme挂载到app

  比如我们顶层的组件，叫App
  app.provider(App)，是一个新的组件，将app的状态，加载在App整个组件树。之后子孙组件，都可以用connect，获取app中的状态，使用挂载的业务对象，更新app状态。
1. connect
  比如,我们在组件树的任意一个组件上，要使用user.login函数，并得到user.name字段,同时还需要当前的主题
  connect((props)=>{
    name:user.name,
    login:user.login,
    theme:theme.currentTheme
  })
  注意connect的参数，是一个函数，函数中的参数props，会由connect将当前组件的属性传入
  这个意味着，这些属性，还可以利用组件自己的属性来组合。
1. compose是个辅助函数，用于按序列执行多个函数
  首先，compose可以将多个hoc包裹在组件上
  其次，多个action可以用compose组合成一个。

1. 结合createStore和connect两个函数，我们几乎能实现所有的组件间的通信
  步骤很简单：创建业务对象->createStore->用store.provider包装顶层组件->子孙组件都可用connect包裹得到需要的属性
1. connect为什么重要：
  因为我们设计一个组件的时候，是不考虑全局状态的
  我们只考虑组件需要什么。
  那么connect可以将不同store的状态、业务对象，它们的状态、更新状态的方法，组合成组件需要的属性。
  换言之，我们要考虑组件自身设计，避免整个应用的各部分互相纠缠。

## hello rees
首先从npm安装rees
npm install rees
然后代码如下：
import React from 'react'
import { createStore,connect } from 'rees'

//actions
const increase = (state, props) => {
  return { counter: state.counter + 1 }
}

//origin ounter
export let Counter = ({counter,increase}) => {
  return (
    <div>
      <button onClick={increase}> counter + </button>
      <span> {counter} </span>
    </div>
  )
}

//a store named app
export let app = createStore({ counter: 0 });

//provider props to origin Counter Component
//notice here!! increase sholud as a function
const CounterWithConnect=connect((props)=>{
  return {
    counter:app.state.counter,
    increase:()=>app.setState(null)(increase)
  }
})(Counter)


//provider app store to the component tree
export default app.provider(CounterWithConnect)

## 实例2 单独创建业务对象
1. counter.state.js

//initState
//如果返回的不是object,却没有id，则store初始化state的时候必须抛出异常
const initState=()=>0

//actions
const increase=(state)=>state+1
const add=(step)=>(state)=>state+step
const addWithProps=(state,props)=>state+props.step

const action={increase,add,addWithProps}

const formatCounter=(state)=>`counter is:${state}`
const models={formatCounter}

//model这么组合,未来还有asyncActions之类?
//这里actions保留原始的actions
//然后可以用createModel来为actions创建代理，即model.add等同于model.setState(withId(add))
const model={initState, action,...models,id:null,setState:null,state:null}
export default model

1. 组件:
import React from 'react'
import { createStore,connect, compose } from 'rees'
import counter from '../counter.state'

let store = createStore({},{counter});

let Counter = ({value,handleIncrease}) => {
  return (
    <div>
      <button onClick={handleIncrease}> counter + </button>
      <span> {value} </span>
    </div>
  )
}

// here,counter is a proxy object,increase is a function,so we must use:
// handleIncrease:(e)=>store.counter.increase()
// not handleIncrease:(e)=>store.counter.increase
export default Counter= compose(
  store.provider,
  connect((props)=>({
    value:store.state.counter,
    handleIncrease:(e)=>store.counter.increase()
  }))
)(Counter)

## 说明：
上面默认导出的，也是一个组件
import App from './app'
<App />就这么现实一个简单的counter ui

## 实践：

1. 按照上述的方式，运行实例

1. 增加减法操作

1. App中增加1个新的Counter组件
  换言之，显示两个Counter组件，点击任何一个加号，两个Counter组件的值都要变化。

## 后续：
1. 这部分实践最多用时3天
  要求对store,store.provider,model,connect有基本的理解
1. 注意action部分，通常我们要用setState(action)更新状态
  我们使用proxy，挂载在store的action，自动的执行了setState
  比如counterState.action.increase,如果执行counterState.incease，则等同于执行了setState(counterState.action.increase)
  这是细节性的东西，便于大家简化代码书写。
1. 之后是rees的异步处理部分：1天
  rees的异步处理，是由asyncModel,showing hoc组成的，周1-周3同样会做整理，充实单元测试，写简单的文档。


